<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Rob Young | digital</title>

  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" referrerpolicy="no-referrer">
  <link href="/style.css" rel="stylesheet">

  
</head>

<body>
  <header>
    <a class="site-header" href="/">Rob Young | <strong>digital</strong></a>

    <div class="filler"></div>

    <nav>
      <ul>
        <li class="here"><a href="/blog">posts</a></li>
      </ul>
    </nav>
  </header>

  <section class="content">
    
<h1>Create your own certificate authority with openssl - part one</h1>

<p><em>31 July 2018</em></p>

<p>This post is part one of a series on working with openssl to manage your
own certificate authority (CA) for a couple of different use cases. If you
just want to get a CA up and running for local development I thoroughly
recommend <a href="https://github.com/FiloSottile/mkcert">mkcert</a>.</p>
<p>In this first part we'll create a CA with openssl, install it into our browser
and test it with a local web server. Note that I'll be providing all the
information on the command line to make it easier to script things.
To see it all tied together see this related <a href="https://github.com/robyoung/nginx-client-certs">github repo</a>.</p>
<h2 id="create-a-certificate-authority-with-openssl">Create a certificate authority with OpenSSL</h2>
<p>First we generate the private key for our CA (with a password other than
'capassword' preferably, and ensure it's not visible in your shell history).</p>
<pre style="background-color:#2b303b;">
<code class="language-bash" data-lang="bash"><span style="color:#c0c5ce;">&gt; openssl </span><span style="color:#bf616a;">genrsa -aes256 -passout</span><span style="color:#c0c5ce;"> pass:capassword</span><span style="color:#bf616a;"> -out</span><span style="color:#c0c5ce;"> test-ca.key 2048</span><span style="color:#c0c5ce;">
</span></code></pre>
<p>Next we generate the root certificate. The fields in the subject name do not
affect the certificate's validity. They are queryable and shown when the certificate
is installed (firefox lists them by organisation) so use something that will remind you what it's for.</p>
<pre style="background-color:#2b303b;">
<code class="language-bash" data-lang="bash"><span style="color:#c0c5ce;">&gt; openssl </span><span style="color:#bf616a;">req -x509 -new -nodes</span><span style="color:#c0c5ce;"> \</span><span style="color:#c0c5ce;">
  </span><span style="color:#bf616a;">-passin</span><span style="color:#c0c5ce;"> pass:capassword \</span><span style="color:#c0c5ce;">
  </span><span style="color:#bf616a;">-key</span><span style="color:#c0c5ce;"> test-ca.key \</span><span style="color:#c0c5ce;">
  </span><span style="color:#bf616a;">-sha256 -days</span><span style="color:#c0c5ce;"> 1825 \</span><span style="color:#c0c5ce;">
  </span><span style="color:#bf616a;">-subj </span><span style="color:#c0c5ce;">&quot;</span><span style="color:#a3be8c;">/C=GB/O=robyoung.digital/CN=test</span><span style="color:#c0c5ce;">&quot; \</span><span style="color:#c0c5ce;">
  </span><span style="color:#bf616a;">-out</span><span style="color:#c0c5ce;"> test-ca.pem</span><span style="color:#c0c5ce;">
</span></code></pre>
<p>And we're done! Next we're going to create a server certificate and sign it
with our shiny new CA key.</p>
<h2 id="create-a-server-certificate">Create a server certificate</h2>
<p>As with the CA, our first step is to generate a private key for our server.
This time we don't want a password otherwise it becomes harder to install.</p>
<pre style="background-color:#2b303b;">
<code class="language-bash" data-lang="bash"><span style="color:#c0c5ce;">&gt; openssl </span><span style="color:#bf616a;">genrsa -out</span><span style="color:#c0c5ce;"> test-server.key 2048</span><span style="color:#c0c5ce;">
</span></code></pre>
<p>Once we have a key we can generate our certificate signing request (CSR),
just like when we're using a public CA. This time the common name
is significant as clients will use it to determine whether the server is
authorised to serve that domain.</p>
<pre style="background-color:#2b303b;">
<code class="language-bash" data-lang="bash"><span style="color:#c0c5ce;">&gt; openssl </span><span style="color:#bf616a;">req -new</span><span style="color:#c0c5ce;"> \</span><span style="color:#c0c5ce;">
  </span><span style="color:#bf616a;">-subj </span><span style="color:#c0c5ce;">&quot;</span><span style="color:#a3be8c;">/C=GB/CN=dev.test</span><span style="color:#c0c5ce;">&quot; \</span><span style="color:#c0c5ce;">
  </span><span style="color:#bf616a;">-key</span><span style="color:#c0c5ce;"> test-server.key \</span><span style="color:#c0c5ce;">
  </span><span style="color:#bf616a;">-out</span><span style="color:#c0c5ce;"> test-server-static-csr.pem</span><span style="color:#c0c5ce;">
</span></code></pre>
<p>If you need to support multiple domains with a single server certificate you
have two options. Wildcard certificates, where you use a star (*) to match a
domain name segment or subject alternative names (SANs).</p>
<p>The wildcard certificate approach is pretty simple.</p>
<pre style="background-color:#2b303b;">
<code class="language-bash" data-lang="bash"><span style="color:#c0c5ce;">&gt; openssl </span><span style="color:#bf616a;">req -new</span><span style="color:#c0c5ce;"> \</span><span style="color:#c0c5ce;">
  </span><span style="color:#bf616a;">-subj </span><span style="color:#c0c5ce;">&quot;</span><span style="color:#a3be8c;">/C=GB/CN=*.dev.test</span><span style="color:#c0c5ce;">&quot; \</span><span style="color:#c0c5ce;">
  </span><span style="color:#bf616a;">-key</span><span style="color:#c0c5ce;"> test-server.key \</span><span style="color:#c0c5ce;">
  </span><span style="color:#bf616a;">-out</span><span style="color:#c0c5ce;"> test-server-wildcard-csr.pem</span><span style="color:#c0c5ce;">
</span></code></pre>
<p>Subject alternative names (SAN) is an x509 extension that allows you
to add multiple domains to a single certificate. It is bit more complex
to implement on the command line. This
<a href="https://security.stackexchange.com/a/91556">Stack Exchange answer</a> helped me
figure out how to do it. The path to your <code>openssl.cnf</code> is going to be system
dependent, on Linux it will probably be <code>/etc/ssl/openssl.cnf</code>, however on Mac
(using a homebrew installed openssl) it is at <code>/usr/local/etc/openssl/openssl.cnf</code>.</p>
<pre style="background-color:#2b303b;">
<code class="language-bash" data-lang="bash"><span style="color:#c0c5ce;">&gt; openssl </span><span style="color:#bf616a;">req -new</span><span style="color:#c0c5ce;"> \</span><span style="color:#c0c5ce;">
  </span><span style="color:#bf616a;">-subj </span><span style="color:#c0c5ce;">&quot;</span><span style="color:#a3be8c;">/C=GB/CN=dev.test</span><span style="color:#c0c5ce;">&quot; \</span><span style="color:#c0c5ce;">
  </span><span style="color:#bf616a;">-key</span><span style="color:#c0c5ce;"> test-server.key \</span><span style="color:#c0c5ce;">
  </span><span style="color:#bf616a;">-out</span><span style="color:#c0c5ce;"> test-server-san-csr.pem \</span><span style="color:#c0c5ce;">
  </span><span style="color:#bf616a;">-reqexts</span><span style="color:#c0c5ce;"> SAN \</span><span style="color:#c0c5ce;">
  </span><span style="color:#bf616a;">-config </span><span style="color:#c0c5ce;">&lt;( </span><span style="color:#bf616a;">\</span><span style="color:#c0c5ce;">
    </span><span style="color:#bf616a;">cat</span><span style="color:#c0c5ce;"> /usr/local/etc/openssl/openssl.cnf \</span><span style="color:#c0c5ce;">
        &lt;(</span><span style="color:#96b5b4;">printf </span><span style="color:#c0c5ce;">&quot;</span><span style="color:#a3be8c;">[SAN]\nsubjectAltName=DNS:one.dev.test,DNS:two.dev.test\n</span><span style="color:#c0c5ce;">&quot;) </span><span style="color:#bf616a;">\</span><span style="color:#c0c5ce;">
  )</span><span style="color:#c0c5ce;">
</span></code></pre>
<p>While this is how you add SANs to a self signed key or a CSR you send to a
public CA, there is unfortunately a <a href="https://www.openssl.org/docs/manmaster/man1/x509.html#BUGS">bug in the x509 command</a>
that means extensions are not passed from certificate requests to certificates.
For our purposes if we want SANs we're going to have to add them when we sign
the CSR.</p>
<p>First, our basic certificate with no SANs. For more information about the
extensions used see the <a href="https://www.openssl.org/docs/manmaster/man5/x509v3_config.html">openssl x509 config docs</a>.</p>
<pre style="background-color:#2b303b;">
<code class="language-bash" data-lang="bash"><span style="color:#c0c5ce;">&gt; openssl </span><span style="color:#bf616a;">x509</span><span style="color:#c0c5ce;"> \</span><span style="color:#c0c5ce;">
  </span><span style="color:#bf616a;">-req -in</span><span style="color:#c0c5ce;"> test-server-static-csr.pem \</span><span style="color:#c0c5ce;">
  </span><span style="color:#bf616a;">-passin</span><span style="color:#c0c5ce;"> pass:capassword \</span><span style="color:#c0c5ce;">
  </span><span style="color:#bf616a;">-CA</span><span style="color:#c0c5ce;"> test-ca.pem</span><span style="color:#bf616a;"> -CAkey</span><span style="color:#c0c5ce;"> test-ca.key</span><span style="color:#bf616a;"> -CAcreateserial</span><span style="color:#c0c5ce;"> \</span><span style="color:#c0c5ce;">
  </span><span style="color:#bf616a;">-out</span><span style="color:#c0c5ce;"> test-server-static-cert.pem \</span><span style="color:#c0c5ce;">
  </span><span style="color:#bf616a;">-days</span><span style="color:#c0c5ce;"> 1825</span><span style="color:#bf616a;"> -sha256</span><span style="color:#c0c5ce;"> \</span><span style="color:#c0c5ce;">
  </span><span style="color:#bf616a;">-extfile </span><span style="color:#c0c5ce;">&lt;( </span><span style="color:#bf616a;">cat </span><span style="color:#c0c5ce;">&lt;&lt;</span><span style="color:#b48ead;">EOF</span><span style="color:#a3be8c;">
subjectKeyIdentifier=hash</span><span style="color:#a3be8c;">
authorityKeyIdentifier=keyid,issuer</span><span style="color:#a3be8c;">
basicConstraints=CA:FALSE</span><span style="color:#a3be8c;">
keyUsage=digitalSignature,keyEncipherment</span><span style="color:#a3be8c;">
</span><span style="color:#b48ead;">EOF</span><span style="color:#c0c5ce;">
)</span><span style="color:#c0c5ce;">
</span></code></pre>
<p>With the SANs it is almost identical but with the <code>subjectAltName</code> extension.</p>
<pre style="background-color:#2b303b;">
<code class="language-bash" data-lang="bash"><span style="color:#c0c5ce;">&gt; openssl </span><span style="color:#bf616a;">x509</span><span style="color:#c0c5ce;"> \</span><span style="color:#c0c5ce;">
  </span><span style="color:#bf616a;">-req -in</span><span style="color:#c0c5ce;"> test-server-static-csr.pem \</span><span style="color:#c0c5ce;">
  </span><span style="color:#bf616a;">-passin</span><span style="color:#c0c5ce;"> pass:capassword \</span><span style="color:#c0c5ce;">
  </span><span style="color:#bf616a;">-CA</span><span style="color:#c0c5ce;"> test-ca.pem</span><span style="color:#bf616a;"> -CAkey</span><span style="color:#c0c5ce;"> test-ca.key</span><span style="color:#bf616a;"> -CAcreateserial</span><span style="color:#c0c5ce;"> \</span><span style="color:#c0c5ce;">
  </span><span style="color:#bf616a;">-out</span><span style="color:#c0c5ce;"> test-server-san-cert.pem \</span><span style="color:#c0c5ce;">
  </span><span style="color:#bf616a;">-days</span><span style="color:#c0c5ce;"> 1825</span><span style="color:#bf616a;"> -sha256</span><span style="color:#c0c5ce;"> \</span><span style="color:#c0c5ce;">
  </span><span style="color:#bf616a;">-extfile </span><span style="color:#c0c5ce;">&lt;( </span><span style="color:#bf616a;">cat </span><span style="color:#c0c5ce;">&lt;&lt;</span><span style="color:#b48ead;">EOF</span><span style="color:#a3be8c;">
subjectKeyIdentifier=hash</span><span style="color:#a3be8c;">
authorityKeyIdentifier=keyid,issuer</span><span style="color:#a3be8c;">
basicConstraints=CA:FALSE</span><span style="color:#a3be8c;">
keyUsage=digitalSignature,keyEncipherment</span><span style="color:#a3be8c;">
subjectAltName=DNS:one.dev.test,DNS:two.dev.test</span><span style="color:#a3be8c;">
</span><span style="color:#b48ead;">EOF</span><span style="color:#c0c5ce;">
)</span><span style="color:#c0c5ce;">
</span></code></pre>
<p>We now have a CA certificate and a couple of server certificates signed by
that CA. It's time to test them out.</p>
<h2 id="test-with-nginx-and-curl">Test with Nginx and Curl</h2>
<p>First let's spin up an Nginx docker container with our static certificate
and server key. We're going to use a minimal ssl configuration, in real life
you're going to want something <a href="https://wiki.mozilla.org/Security/TLS_Configurations#Nginx">much more robust</a>.</p>
<p><code>nginx.vhost.conf</code></p>
<pre style="background-color:#2b303b;">
<code class="language-nginx" data-lang="nginx"><span style="color:#c0c5ce;">server {</span><span style="color:#c0c5ce;">
  listen 443 ssl;</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">
  server_name dev.test;</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">
  ssl_certificate /etc/nginx/ssl/certs/server-crt.pem;</span><span style="color:#c0c5ce;">
  ssl_certificate_key /etc/nginx/ssl/private/server.key;</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">
  location / {</span><span style="color:#c0c5ce;">
    return 200 &#39;Static vhost test\n&#39;;</span><span style="color:#c0c5ce;">
    add_header Content-Type text/plain;</span><span style="color:#c0c5ce;">
  }</span><span style="color:#c0c5ce;">
}</span><span style="color:#c0c5ce;">
</span></code></pre><pre style="background-color:#2b303b;">
<code class="language-bash" data-lang="bash"><span style="color:#c0c5ce;">&gt; docker </span><span style="color:#bf616a;">run</span><span style="color:#c0c5ce;"> \</span><span style="color:#c0c5ce;">
  </span><span style="color:#bf616a;">--rm -p</span><span style="color:#c0c5ce;"> 443:443 \</span><span style="color:#c0c5ce;">
  </span><span style="color:#bf616a;">-v </span><span style="color:#c0c5ce;">$(</span><span style="color:#bf616a;">pwd</span><span style="color:#c0c5ce;">)/nginx.vhost.conf:/etc/nginx/conf.d/default.conf:ro \</span><span style="color:#c0c5ce;">
  </span><span style="color:#bf616a;">-v </span><span style="color:#c0c5ce;">$(</span><span style="color:#bf616a;">pwd</span><span style="color:#c0c5ce;">)/test-server.key:/etc/nginx/ssl/private/server.key:ro \</span><span style="color:#c0c5ce;">
  </span><span style="color:#bf616a;">-v </span><span style="color:#c0c5ce;">$(</span><span style="color:#bf616a;">pwd</span><span style="color:#c0c5ce;">)/test-server-static-cert.pem:/etc/nginx/ssl/certs/server-crt.pem:ro \</span><span style="color:#c0c5ce;">
  </span><span style="color:#bf616a;">nginx</span><span style="color:#c0c5ce;">
</span></code></pre>
<p>Before we finally test this we're going to need <code>dev.test</code> to point to <code>127.0.0.1</code>.
If we were just testing with cur we could make use of the <a href="https://curl.haxx.se/docs/manpage.html#--resolve"><code>--resolve</code></a>
option to manually resolve. However, we also want this to work in a browser
so let's add it to our hosts file.</p>
<pre style="background-color:#2b303b;">
<code class="language-bash" data-lang="bash"><span style="color:#c0c5ce;">&gt; echo &quot;</span><span style="color:#a3be8c;">127.0.0.1 dev.test</span><span style="color:#c0c5ce;">&quot; &gt;&gt; /etc/hosts</span><span style="color:#c0c5ce;">
</span></code></pre>
<p>Finally we're able test our certificate!</p>
<pre style="background-color:#2b303b;">
<code class="language-bash" data-lang="bash"><span style="color:#c0c5ce;">&gt; curl </span><span style="color:#bf616a;">--cacert</span><span style="color:#c0c5ce;"> test-ca.pem https://dev.test</span><span style="color:#c0c5ce;">
</span><span style="color:#bf616a;">Static</span><span style="color:#c0c5ce;"> vhost test</span><span style="color:#c0c5ce;">
</span></code></pre><h2 id="install-the-certificate-authority">Install the certificate authority</h2>
<p>In order to test this in a browser we need to install the CA certificate. This
process varies between different platforms and can be tempremental (which is
one of the reasons <a href="https://github.com/FiloSottile/mkcert">mkcert</a> is so great).
To make my life easier I'm going to describe adding the CA certificate to
Firefox as it allows you to manage your authorities from it's own preferences.</p>
<p>First open your Firefox &quot;Preferences&quot;. Select &quot;Privacy &amp; Security&quot;. Scroll all
the way to the bottom and click &quot;View Certificates&quot;. Here we want to click the
tab called &quot;Authorities&quot; and then click &quot;Import&quot;. Select our <code>test-ca.pem</code> and
import.</p>
<p>You should now be able to visit <a href="https://dev.test">https://dev.test</a> in Firefox
and see &quot;Static vhost test&quot; displayed. And we're done!</p>
<h2 id="next-steps">Next steps</h2>
<p>This has been a bit of a monster post but we now have a CA certificate installed
in our browser, a process for creating signed server certificates and a web
server that tests this out, all created with easily scriptable commands. In
the next post we'll create client certificates to identify ourselves with our
servers.</p>


  </section>
</body>

</html>
